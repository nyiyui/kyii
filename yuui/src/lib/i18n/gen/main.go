package main

import (
	"flag"
	"html/template"
	"log"
	"os"
	"time"

	"github.com/pelletier/go-toml"
)

const tmpl = `
import i18n from 'sveltekit-i18n';

// generated by nyiyui.ca/kyii/yuui/src/lib/i18n/gen on {{now}}

/** @type {import('sveltekit-i18n').Config} */
export const config = ({
	translations: {
		{{ range $c, $l := $.Locales }}
		"{{ $c }}": {
			lang: {
				{{ range $k, $v := $l.Name -}}
				"{{ $k }}": "{{ $v }}",
				{{- end }}
			},
		},
		{{- end }}
	},
  loaders: [
		{{ range $c, $l := $.Locales }}
		{{ $default := $.Locale.Default | eq $c }}
		{{ range $j, $r := $.Routes }}
		{
			locale: '{{ $c }}',
			key: '{{ $r.Key }}',
			{{ with $r.Routes -}}
			routes: [
				{{ range . }}
				'{{ . }}',
				{{ end }}
			],
			{{- end }}
			loader: async () => ( await import('./{{ $c }}/{{ $r.Key }}.json') ).default,
		},
		{{ end }}
		{{ end }}
  ],
});

export const { t, locale, locales, loading, loadTranslations } = new i18n(config);

loading.subscribe(($loading) => $loading && console.log('Loading translations...'));
`

func main() {
	var cfgP string
	var destP string
	flag.StringVar(&cfgP, "config", "./trs.toml", "path to config file")
	flag.StringVar(&destP, "dest", "./index.ts", "path to destination file")
	flag.Parse()

	c, err := loadConfig(cfgP)
	if err != nil {
		log.Fatalf("load config: %s", err)
	}

	t, err := template.New("").Funcs(template.FuncMap{
		"now": func() string {
			return time.Now().Format(time.RFC3339)
		},
	}).
		Parse(tmpl)
	if err != nil {
		log.Fatalf("load tmpl: %s", err)
	}

	err = execTmpl(*c, t, destP)
	if err != nil {
		log.Fatalf("exec tmpl: %s", err)
	}
}

type Config struct {
	Routes  []Route           `toml:"routes"`
	Locale  LocaleConfig      `toml:"locale"`
	Locales map[string]Locale `toml:"locales"`
}

type Route struct {
	Key    string   `toml:"key"`
	Routes []string `toml:"routes"`
}

type LocaleConfig struct {
	Default string `toml:"default"`
}

type Locale struct {
	Name map[string]string `toml:"name"`
}

func execTmpl(c Config, t *template.Template, path string) (err error) {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer func() {
		err2 := f.Close()
		if err2 != nil {
			err = err2
		}
	}()
	err = t.Execute(f, c)
	return err
}

func loadConfig(path string) (c *Config, err error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer func() {
		err2 := f.Close()
		if err2 != nil {
			err = err2
		}
	}()
	c = &Config{}
	err = toml.NewDecoder(f).Decode(c)
	if err != nil {
		return nil, err
	}
	return c, nil
}
